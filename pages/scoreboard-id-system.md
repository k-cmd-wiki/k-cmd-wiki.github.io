# 스코어보드 ID 시스템
<hr>

커맨드나 데이터팩 개발을 하다가 보면 여러 엔티티들 중 스코어 값이 같은 엔티티를 감지하고 싶을 때가 있습니다.

스코어 값을 비교하는 기존의 구문인 `if score` 에서, 첫 번째 대상은 `execute as`와 `@s`를 이용하지만, 바로 이어지는 두 번째 비교 대상은 한 개체만 지정 가능합니다. 이럴 때는, 랜덤한 개체를 찾는 조건을 켜고 감지가 될 때까지 재귀함수를 돌려버릴 수도 없고 참 난감한 상황이 펼쳐집니다.

로그 감자(`자신`)가 처음 커맨드를 배울 때 저지른 귀여운(?)실수가 있었는데, 그 시절 저는 `execute as @a at @s` 를 `execute at @a as @p` 로 쓰는 만행을 저질렀었습니다.

그러나 이 만행으로 인해 얻게 되는 아이디어가 하나 있었습니다. 바로 `as` 뿐만 아니라 "**위치(`at`)로도 대상을 지정할 수가 있다.**" 는 것. 즉, 한 커맨드 안에서 여러 대상을 두 개나 감지할 수 있게 되었다는 것이죠.

이 경험을 예로, 갑옷 거치대와 크리퍼들 중 스코어가 같은 쌍을 감지해봅시다.

```mcfunction
execute as 갑옷 거치대들 at 크리퍼들 if score @s asdf = @e[limit=1,sort=nearest] asdf run say 감지!
 ```

일반적으로 크리퍼 두 마리가 정확히 동일한 좌표에 있을 일은 없으므로 정상적으로 감지에 성공할 것입니다. 두 엔티티 중 갑옷 거치대는 `@s` 로, 크리퍼는 `@e[limit=1,sort=nearest]` 로 감지됩니다.

원리는 간단합니다. `as` 에 의해 '어느 한 갑옷 거치대'이 대상으로 정해지고, `at` 에 의해 '어느 한 크리퍼'의 위치에서 명령어를 실행합니다. 따라서, 크리퍼의 위치에서 가장 가까운 엔티티는 '그 크리퍼'이므로 '그 갑옷 거치대'와 '그 크리퍼' 둘을 서로 비교하게 됩니다.

만약 둘의 스코어가 같지 않다면 '그 갑옷 거치대'라는 대상은 유지된 채로 '또 다른 크리퍼'와 스코어를 비교하게 되고, 이것이 반복됩니다.

가능한 모든 크리퍼와 비교를 했음에도 스코어가 같은 짝을 찾지 못했다면, 이제 '그 갑옷 거치대'가 아닌 다른 갑옷 거치대를 주체로 모든 크리퍼와 짝을 찾는 것을 다시 하게 됩니다. 이렇게 가능한 모든 경우의 수를 하나씩 찾는 노가다 급의 일이 저 한 줄에서 일어나는 것입니다.

이해가 안 된다면 맨 하단에서 Towercrain님이 올린 사진을 보도록 합시다.

그러나 우리의 짖궂은 플레이어들이 대상이라면 코너에 서로 겹치면서 정확히 같은 좌표에 서 버그를 유발하려고 난리를 칠 것입니다.

이때는, 데이터팩 함수를 두 개 이용하여 본 위치의 대한 문제를 해결할 수 있습니다. `self` 태그를 이용해봅시다.

```mcfunction
감지함수1
{
tag @s add self
execute as 크리퍼들 run function 감지함수2
tag @s remove self
}
```
```mcfunction
감지함수2
{
execute if score @s asdf = @e[tag=self,limit=1] run say 감지!
}
```

위와 같이 함수를 작성하고 `execute as 갑옷 거치대들 run function 감지함수1` 을 실행하게 된다면, 감지함수 1에서 `@s` 는 갑옷 거치대가 선택됨으로 갑옷 거치대에게 `self` 태그가 부여되어 크리퍼를 주체로 한 감지함수 2가 실행됩니다.

감지함수 2에서는 `@s` 가 크리퍼이며, `self` 태그는 이전에 감지함수 1에서의 주체인 '그 갑옷 거치대' 한 마리만 가지고 있으므로 정상적으로 감지에 성공하게 됩니다.

감지함수 2에서 크리퍼는 `@s` 로, 갑옷 거치대는  `@e[tag=self,limit=1]` 로 작성하면 됩니다. 위 함수를 조금 다르게 수정한다면, 꼭 갑옷 거치대와 크리퍼라는 엔티티에 한정되지 않고 엔티티의 종류가 같을 때에도, 서로 같은 스코어값 가진 둘을 감지하는 것도 가능해집니다.
